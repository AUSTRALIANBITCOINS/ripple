- content_for :title do
  Model Design

%section#basics
  :markdown
    ## Basic Model

    Make a new model in `app/models`.

        class Post
          include Ripple::Document

          property :name, String, presence: true
          property :body, String, presence: true

          timestamps!
        end

  = source_dive do
    :markdown
      For more about what property classes are available, look at
      [`core_ext/casting.rb`](https://github.com/basho/ripple/blob/master/lib/ripple/core_ext/casting.rb).
      The short answer is that instances of a property class need a `ripple_cast`
      method.

  :markdown
    This model has two `String` properties. Some of the other classes available
    for properties are `Integer`, `Float`, `Numeric`, `Symbol`, `Boolean`,
    `Time`, `Date`, and `DateTime`.

    Both `String` properties are required to be present.

    Let's play with an instance of the Post class:

        p = Post.new
        p.name = "first post"
        p.body = "this post is rad!!!\n" * 10

        p.save

        p.key #=> "37458abc752f8413e"

        p2 = Post.find "37458abc752f8413e"

        p.name #=> "first post"

%section#keys
  :markdown
    ## Alternate Keys

    Sometimes you don't want a Riak-assigned key: "37458abc752f8413e" is pretty
    gross.

  = source_dive do
    :markdown
      Key logic is defined in 
      [`document/key.rb`](https://github.com/basho/ripple/blob/master/lib/ripple/document/key.rb).

  :markdown
    You can use `key_on` to declare a single property as the key:

        class User
          include Ripple::Document
          property :email, String, presence: true

          key_on :email
        end

    Ripple calls the `key` method to figure out the key, so if you want a 
    composite key (or really any complicated key) you can define it that way:

        class Timeseries
          include Ripple::Document
          property :date, Date
          property :column, String

          def key
            "\#{column}-\#{date}"
          end
        end

    You can also just assign the key yourself.

        p = Post.new key: 'first-post', name: 'first post', body: 'rad post 1000'
        p.save

        p.key #=> "first-post"

    If you have a complicated keying setup, it might be worthwhile to move
    keying logic to a separate class:

        class TimeseriesKey
          attr_accessor :column, :user_key
          attr_reader :date

          # http://en.wikipedia.org/wiki/Record_separator#Field_separators
          UNIT_SEPARATOR = "\x1f"

          def initialize(opts)
            initialize_from_key(opts) if opts.is_a? String

            # the implementation of this is left as an exercise for the reader
            initialize_from_options(opts) if opts.is_a? Hash
          end

          def initialize_from_key(opts)
            self.date, self.column, self.user_key = opts.split(UNIT_SEPARATOR)
          end

          def date=(new_date)
            # coerce new_date to the appropriate type
          end

          def to_s
            [date, column, user_key].join UNIT_SEPARATOR
          end
        end

        class Timeseries
          include Ripple::Document
          property :date, Date
          property :column, String
          one :user, using: :stored_key

          def key
            @key ||= TimeseriesKey.new(attributes).to_s
          end
        end

    By having this logic isolated, it becomes much easier to test and reason
    about independently from the model or business logic.
